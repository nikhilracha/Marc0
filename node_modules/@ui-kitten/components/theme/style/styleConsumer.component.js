/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import React from 'react';
import hoistNonReactStatics from 'hoist-non-react-statics';
import { StyleConsumerService } from './styleConsumer.service';
import { MappingContext } from '../mapping/mappingContext';
import { ThemeContext } from '../theme/themeContext';
/**
 * `styled` is a High Order Function which is used to apply style mapping on component.
 *
 * Requires component to have `styledComponentName` string property which defines
 * corresponding component name in mapping. (e.g 'Button' for Button component).
 * Returns component class which can be used as styled component.
 *
 * @property {string} appearance - Determines style appearance of component. Default is provided by mapping.
 *
 * @property {ThemeType} theme - Determines theme used to style component.
 *
 * @property {StyleType} themedStyle - Determines component style for it's current state.
 *
 * @property {(interaction: Interaction[]) => void} dispatch - Determines function
 * for dispatching current state of component. This is designed to be used as style request function.
 * Calls component re-render if style for requested state differ from current.
 *
 * @param Component - Type: {ComponentType}. Determines class or functional component to be styled.
 *
 * @overview-example Declaring Styled Component
 *
 * ```
 * import React from 'react';
 * import { TouchableOpacity } from 'react-native';
 * import { styled, Interaction } from '../..';
 *
 * class Button extends React.Component {
 *
 *   // Define component name used in `mapping`
 *   static styledComponentName = 'Button';
 *
 *   onPressIn = (e) => {
 *     // Request styles for `active` state and re-render
 *
 *     this.props.dispatch([Interaction.ACTIVE]);
 *
 *     if(this.props.onPressIn) {
 *       this.props.onPressIn(e);
 *     }
 *   };
 *
 *   onPressOut = (e) => {
 *     // Request styles for default state and re-render
 *
 *     this.props.dispatch([]);
 *
 *     if(this.props.onPressOut) {
 *       this.props.onPressOut(e);
 *     }
 *   };
 *
 *   render() {
 *     // Retrieve styles for current state from props (provided with themedStyle prop)
 *     // And apply it with saving priority of `style` prop
 *
 *     const { style, themedStyle, ...restProps } = this.props;
 *
 *     return (
 *       <TouchableOpacity
 *         {...restProps}
 *         style={[themedStyle, style]}
 *         onPressIn={this.onPressIn}
 *         onPressOut={this.onPressOut}
 *       />
 *     );
 *   }
 * }
 *
 * export const StyledButton = styled(Button);
 * ```
 *
 * @overview-example Styled Component Usage
 *
 * ```
 * import React from 'react';
 * import { StyledButton } from './path-to/styledButton.component';
 *
 * export const StyledButtonShowcase = (props) => (
 *   <StyledButton {...props}/>
 * );
 * ```
 */
export const styled = (Component) => {
    // @ts-ignore
    if (!Component.styledComponentName) {
        console.warn('Styled components should specify corresponding style name.');
        return null;
    }
    class Wrapper extends React.Component {
        constructor() {
            super(...arguments);
            this.state = {
                interaction: [],
            };
            this.init = false;
            this.onInit = (context) => {
                // @ts-ignore
                this.service = new StyleConsumerService(Component.styledComponentName, context);
                this.defaultProps = this.service.createDefaultProps();
                this.init = true;
            };
            this.onDispatch = (interaction) => {
                this.setState({ interaction });
            };
            this.withStyledProps = (source, context) => {
                const { interaction } = this.state;
                const props = { ...this.defaultProps, ...source };
                return this.service.withStyledProps(props, context, interaction);
            };
            this.renderWrappedElement = (context) => {
                if (!this.init) {
                    this.onInit(context);
                }
                const { forwardedRef, ...restProps } = this.props;
                const props = this.withStyledProps(restProps, context);
                return (React.createElement(Component, Object.assign({}, props, { ref: forwardedRef, dispatch: this.onDispatch })));
            };
        }
        render() {
            const StyledElement = this.renderWrappedElement;
            return (React.createElement(MappingContext.Consumer, null, (styles) => (React.createElement(ThemeContext.Consumer, null, (theme) => (React.createElement(StyledElement, { style: styles, theme: theme }))))));
        }
    }
    const WrappingElement = (props, ref) => {
        return (
        // @ts-ignore
        React.createElement(Wrapper, Object.assign({}, props, { forwardedRef: ref })));
    };
    const ResultComponent = React.forwardRef(WrappingElement);
    ResultComponent.displayName = Component.displayName || Component.name;
    // @ts-ignore
    hoistNonReactStatics(ResultComponent, Component);
    // @ts-ignore
    return ResultComponent;
};
//# sourceMappingURL=styleConsumer.component.js.map