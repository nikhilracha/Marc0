export class SelectionStrategy {
    constructor(options, data, keyExtractor) {
        this.selectedOption = options;
        this.keyExtractor = keyExtractor;
        this.verifyData(data);
    }
    compareOptions(option1, option2) {
        if (!this.keyExtractor) {
            return option1 === option2;
        }
        else {
            return (option1 && option2) && this.keyExtractor(option1) === this.keyExtractor(option2);
        }
    }
    hasOptionSubItems(option) {
        return option.items && option.items.length !== 0;
    }
    processData(data) {
        return data
            .reduce((acc, current) => {
            if (this.hasOptionSubItems(current)) {
                const subTexts = current.items.map((item) => {
                    return item.text;
                });
                return acc.concat(subTexts);
            }
            else {
                acc.push(current.text);
                return acc;
            }
        }, []);
    }
}
export class MultiSelectStrategy extends SelectionStrategy {
    constructor(options = [], data, keyExtractor) {
        if (Array.isArray(options)) {
            super(options, data, keyExtractor);
        }
    }
    select(option, callback) {
        const subOptionsExist = this.hasOptionSubItems(option);
        if (subOptionsExist) {
            this.selectOptionWithSubOptions(option);
        }
        else {
            this.selectDefaultOption(option);
        }
        return this.selectedOption;
    }
    selectDefaultOption(option) {
        const optionAlreadyExist = this.selectedOption
            .some((item) => {
            return this.compareOptions(item, option);
        });
        if (optionAlreadyExist) {
            this.removeOption(option);
        }
        else {
            this.selectedOption.push(option);
        }
    }
    selectOptionWithSubOptions(option) {
        const subOptionsAlreadyExist = this.selectedOption
            .some((item) => {
            return option.items
                .some((subItem) => {
                return subItem === item;
            });
        });
        if (subOptionsAlreadyExist) {
            option.items.forEach((subItem) => this.removeOption(subItem));
        }
        else {
            const enabledItems = option.items
                .filter((item) => {
                return !item.disabled;
            });
            this.selectedOption = this.selectedOption.concat(enabledItems);
        }
    }
    getPlaceholder(placeholder) {
        if (this.isSelectedOptionExist()) {
            return this.selectedOption
                .map((item) => {
                return item && item.text;
            })
                .join(', ');
        }
        else {
            return placeholder;
        }
    }
    isSelected(item) {
        return this.selectedOption
            .some((option) => {
            return this.compareOptions(item, option);
        });
    }
    isSelectedOptionExist() {
        return this.selectedOption && this.selectedOption.length !== 0;
    }
    removeOption(option) {
        const index = this.selectedOption
            .findIndex((item) => {
            return this.compareOptions(item, option);
        });
        if (index !== -1) {
            this.selectedOption.splice(index, 1);
        }
    }
    verifyData(data) {
        const selectedItemsAreCorrect = this.processData(data).some((item) => {
            return this.selectedOption.some((selected) => {
                return selected.text === item;
            });
        });
        if (!selectedItemsAreCorrect && this.selectedOption.length !== 0) {
            const message = `Some Option doesn't exist in the data array or you ` +
                'set Main group option selected.';
            throw Error(message);
        }
    }
}
export class SingleSelectStrategy extends SelectionStrategy {
    constructor(options, data, keyExtractor) {
        if (!Array.isArray(options)) {
            super(options, data, keyExtractor);
        }
    }
    select(option, callback) {
        this.selectedOption = option;
        if (callback) {
            callback();
        }
        return this.selectedOption;
    }
    getPlaceholder(placeholder) {
        if (this.selectedOption) {
            return this.selectedOption.text;
        }
        else {
            return placeholder;
        }
    }
    isSelected(item) {
        if (this.hasOptionSubItems(item)) {
            return item.items.some((option) => {
                return this.isSelected(option);
            });
        }
        else {
            return this.compareOptions(item, this.selectedOption);
        }
    }
    verifyData(data) {
        const selectedItemsAreCorrect = this.processData(data).some((item) => {
            if (this.selectedOption) {
                return item === this.selectedOption.text;
            }
        });
        if (!selectedItemsAreCorrect && this.selectedOption) {
            const message = `Option \"${this.selectedOption.text}\" doesn't exist in the data array!`;
            throw Error(message);
        }
    }
}
//# sourceMappingURL=selection.strategy.js.map